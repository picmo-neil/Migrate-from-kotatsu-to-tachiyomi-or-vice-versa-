import os
import json
import zipfile
import gzip
import hashlib
import struct
import urllib.request
from urllib.parse import urlparse

# Import the compiled protobuf schema (generated by GitHub Actions)
try:
    import tachiyomi_pb2
except ImportError:
    print("‚ùå Error: tachiyomi_pb2.py not found. Did you run protoc?")
    exit(1)

# --- CONFIG ---
KOTATSU_INPUT = 'Backup.zip'
TACHI_INPUT = 'Backup.tachibk'
OUTPUT_DIR = 'output'

if not os.path.exists(OUTPUT_DIR):
    os.makedirs(OUTPUT_DIR)

# --- üèÜ GOLDEN DATABASE (Python Dictionary) ---
# Maps Domains -> (Signed Int64 ID, Name)
GOLDEN_DB = {
    "mangadex.org": (2499283573021220255, "MangaDex"),
    "manganato.com": (1791778683660516, "Manganato"),
    "chapmanganato.com": (1791778683660516, "Manganato"),
    "readmanganato.com": (1791778683660516, "Manganato"),
    "mangakakalot.com": (2229245767045543, "Mangakakalot"),
    "bato.to": (73976367851206, "Bato.to"),
    "battwo.com": (73976367851206, "Bato.to"),
    "mto.to": (73976367851206, "Bato.to"),
    "asuratoon.com": (6676140324647343467, "Asura Scans"),
    "asurascans.com": (6676140324647343467, "Asura Scans"),
    "flamecomics.com": (7350700882194883466, "Flame Comics"),
    "reaperscans.com": (5113063529342730466, "Reaper Scans"),
    "comick.io": (4689626359218228302, "Comick"),
    "nhentai.net": (7670359809983944111, "NHentai"),
}

# --- KOTATSU MAPPING ---
KOTATSU_OVERRIDES = {
    "MANGADEX": "MANGADEX",
    "MANGANATO": "MANGANATO",
    "BATOTO": "BATOTO",
    "ASURA_SCANS": "ASURA_SCANS",
    "MANGAKAKALOT": "MANGAKAKALOT"
}

# --- UTILS ---

def get_domain(url):
    if not url: return None
    if not url.startswith('http'): url = 'https://' + url
    try:
        parsed = urlparse(url)
        domain = parsed.netloc
        domain = domain.replace('www.', '').replace('m.', '')
        # Remove version prefixes like v3.
        if domain.startswith('v') and domain[1].isdigit() and domain[2] == '.':
            domain = domain[3:]
        return domain
    except:
        return None

def java_string_hashcode(s):
    """
    Simulates Java's String.hashCode(), but extends it to 64-bit to match
    Tachiyomi's fallback hashing mechanism for source IDs.
    """
    h = 0
    for c in s:
        h = (31 * h + ord(c)) & 0xFFFFFFFFFFFFFFFF
    
    # Convert unsigned 64-bit to signed 64-bit
    return struct.unpack('q', struct.pack('Q', h))[0]

def to_signed_64(val):
    """Ensures a value is treated as a signed 64-bit integer."""
    try:
        val = int(val)
        return struct.unpack('q', struct.pack('Q', val & 0xFFFFFFFFFFFFFFFF))[0]
    except:
        return 0

# --- SOURCE REGISTRY ---
class SourceRegistry:
    """
    Acts as a source of truth. Prevents 'Unrecognized Extension' by
    ensuring every ID used in the backup is also registered in backupSources.
    """
    def __init__(self):
        self.sources = {} # ID -> Name

    def register(self, source_id, name):
        sid = to_signed_64(source_id)
        if sid not in self.sources:
            self.sources[sid] = name
        return sid

    def get_list(self):
        lst = []
        for sid, name in self.sources.items():
            s = tachiyomi_pb2.BackupSource()
            s.sourceId = sid
            s.name = name
            lst.append(s)
        return lst

# --- CONVERTERS ---

def kotatsu_to_tachiyomi():
    print("üîÑ Converting Kotatsu -> Tachiyomi")
    
    # Load Zip
    with zipfile.ZipFile(KOTATSU_INPUT, 'r') as z:
        # Find favorites json
        fav_file = next((n for n in z.namelist() if 'favourites' in n), None)
        if not fav_file: raise Exception("No favourites found in zip")
        fav_data = json.loads(z.read(fav_file))

    registry = SourceRegistry()
    backup = tachiyomi_pb2.Backup()

    for item in fav_data:
        manga_data = item.get('manga', {})
        url = manga_data.get('url', '') or manga_data.get('public_url', '')
        title = manga_data.get('title', '')
        k_source = manga_data.get('source', '')
        
        domain = get_domain(url)
        
        # ID LOGIC
        final_id = 0
        final_name = k_source

        # 1. Golden DB Check
        if domain in GOLDEN_DB:
            final_id, final_name = GOLDEN_DB[domain]
        else:
            # 2. Fallback Hash
            # Generate a hash based on Source Name + Domain to be reasonably unique
            seed = f"{k_source}{domain}"
            final_id = java_string_hashcode(seed)
            final_name = f"{k_source} ({domain})" if domain else k_source

        # Register Source (CRITICAL STEP)
        final_id = registry.register(final_id, final_name)

        # Build Proto Object
        bm = backup.backupManga.add()
        bm.source = final_id
        bm.url = url
        bm.title = title
        bm.artist = manga_data.get('artist', '') or ''
        bm.author = manga_data.get('author', '') or ''
        bm.description = manga_data.get('description', '') or ''
        bm.status = 1 if manga_data.get('state') == 'ONGOING' else 2
        bm.thumbnailUrl = manga_data.get('cover_url', '') or ''
        bm.dateAdded = int(item.get('created_at', 0))
        
        # Add genres
        for tag in manga_data.get('tags', []):
            bm.genre.append(tag)

    # Attach Sources
    backup.backupSources.extend(registry.get_list())

    # Write
    out_path = os.path.join(OUTPUT_DIR, 'Backup.tachibk')
    with gzip.open(out_path, 'wb') as f:
        f.write(backup.SerializeToString())
    
    print(f"‚úÖ Created {out_path} with {len(backup.backupManga)} entries.")

def tachiyomi_to_kotatsu():
    print("üîÑ Converting Tachiyomi -> Kotatsu")
    
    with gzip.open(TACHI_INPUT, 'rb') as f:
        backup = tachiyomi_pb2.Backup()
        backup.ParseFromString(f.read())

    # Map ID -> Name
    source_map = {s.sourceId: s.name for s in backup.backupSources}
    
    favorites = []
    
    for tm in backup.backupManga:
        s_name = source_map.get(tm.source, "Unknown")
        domain = get_domain(tm.url)
        
        # LOGIC: Resolve Kotatsu Enum
        k_key = "MANGADEX" # Default
        
        # 1. Check Overrides
        upper_name = s_name.upper().replace(" ", "_")
        if upper_name in KOTATSU_OVERRIDES:
            k_key = KOTATSU_OVERRIDES[upper_name]
        elif domain == "mangadex.org": k_key = "MANGADEX"
        elif domain == "manganato.com": k_key = "MANGANATO"
        elif domain == "bato.to": k_key = "BATOTO"
        else:
            # Heuristic match
            cleaned = upper_name.replace("_SCANS", "").replace("_COMICS", "")
            k_key = cleaned

        # Generate Kotatsu ID (String Hash)
        # Kotatsu uses a Long hash converted to String
        seed = f"{k_key}{tm.url}"
        kid = str(java_string_hashcode(seed))

        favorites.append({
            "manga_id": kid,
            "category_id": 0,
            "sort_key": 0,
            "created_at": tm.dateAdded,
            "manga": {
                "id": kid,
                "title": tm.title,
                "url": tm.url,
                "public_url": None,
                "source": k_key,
                "state": "FINISHED" if tm.status == 2 else "ONGOING",
                "cover_url": tm.thumbnailUrl,
                "tags": list(tm.genre),
                "author": tm.author
            }
        })

    # Create Zip
    out_path = os.path.join(OUTPUT_DIR, 'Backup.zip')
    with zipfile.ZipFile(out_path, 'w') as z:
        z.writestr("favourites", json.dumps(favorites))
        z.writestr("history", "[]")
        z.writestr("categories", "[]")
        z.writestr("index", json.dumps({"version": 2, "created_at": 0, "app_version": "50.0"}))
    
    print(f"‚úÖ Created {out_path} with {len(favorites)} entries.")

# --- MAIN ENTRY ---
if __name__ == "__main__":
    if os.path.exists(KOTATSU_INPUT):
        kotatsu_to_tachiyomi()
    elif os.path.exists(TACHI_INPUT):
        tachiyomi_to_kotatsu()
    else:
        print("‚ùå No backup file found (Backup.zip or Backup.tachibk)")
        exit(1)
